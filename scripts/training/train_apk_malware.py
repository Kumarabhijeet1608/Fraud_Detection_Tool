#!/usr/bin/env python3
"""
APK Malware Detection Model Training Script

This script trains a Random Forest model for Android APK malware detection
using static analysis features extracted from APK files.

Features:
- API call signatures
- Permission analysis
- File structure features
- Static code analysis
- Feature selection and optimization
"""

import pandas as pd
import numpy as np
import json
import pickle
import logging
from typing import Dict, List, Tuple, Any
from sklearn.model_selection import train_test_split, StratifiedKFold, GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score
from sklearn.feature_selection import SelectKBest, f_classif
import warnings
warnings.filterwarnings('ignore')

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class APKMalwareTrainer:
    """
    Trainer class for APK malware detection model.
    
    This class handles feature extraction, model training, and evaluation
    for Android APK malware detection using static analysis features.
    """

    def __init__(self):
        """Initialize the trainer with default parameters."""
        self.model = None
        self.scaler = None
        self.feature_selector = None
        self.label_encoder = None
        self.feature_names = None
        self.selected_features = None
        
    def load_data(self, data_path: str) -> pd.DataFrame:
        """
        Load training data from file.
        
        Args:
            data_path: Path to the training data file
            
        Returns:
            Loaded DataFrame with APK features and labels
        """
        try:
            logger.info(f"Loading data from {data_path}")
            
            # Try different file formats
            if data_path.endswith('.csv'):
                df = pd.read_csv(data_path)
            elif data_path.endswith('.parquet'):
                df = pd.read_parquet(data_path)
            elif data_path.endswith('.json'):
                df = pd.read_json(data_path)
            else:
                raise ValueError("Unsupported file format")
            
            logger.info(f"Loaded {len(df)} APK samples")
            return df
            
        except Exception as e:
            logger.error(f"Failed to load data: {e}")
            raise
    
    def prepare_features(self, df: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray, List[str]]:
        """
        Prepare features for training.
        
        Args:
            df: DataFrame with APK features and labels
            
        Returns:
            Tuple of (X_features, y_labels, feature_names)
        """
        logger.info("Preparing APK features for training")
        
        # Separate features and labels
        feature_columns = [col for col in df.columns if col != 'label']
        X = df[feature_columns].values
        y = df['label'].values
        
        # Store feature names
        self.feature_names = feature_columns
        
        # Handle missing values
        X = np.nan_to_num(X, nan=0.0)
        
        # Convert labels to numeric if needed
        if y.dtype == 'object':
            self.label_encoder = LabelEncoder()
            y = self.label_encoder.fit_transform(y)
        
        logger.info(f"Prepared {X.shape[1]} features from {len(feature_columns)} columns")
        return X, y, self.feature_names
    
    def select_features(self, X: np.ndarray, y: np.ndarray, k: int = 100) -> np.ndarray:
        """
        Select the most important features using statistical tests.
        
        Args:
            X: Feature matrix
            y: Target labels
            k: Number of features to select
            
        Returns:
            Feature matrix with selected features
        """
        logger.info(f"Selecting top {k} features")
        
        # Use F-test for feature selection
        self.feature_selector = SelectKBest(score_func=f_classif, k=min(k, X.shape[1]))
        X_selected = self.feature_selector.fit_transform(X, y)
        
        # Get selected feature names
        selected_indices = self.feature_selector.get_support()
        self.selected_features = [self.feature_names[i] for i in range(len(self.feature_names)) if selected_indices[i]]
        
        logger.info(f"Selected {X_selected.shape[1]} features")
        return X_selected
    
    def train_model(self, X: np.ndarray, y: np.ndarray) -> None:
        """
        Train the APK malware detection model.
        
        Args:
            X: Feature matrix
            y: Target labels
        """
        logger.info("Training APK malware detection model")
        
        # Split data
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, stratify=y
        )
        
        # Scale features
        self.scaler = StandardScaler()
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)
        
        # Train base model
        base_model = RandomForestClassifier(
            n_estimators=100,
            random_state=42,
            class_weight='balanced',
            n_jobs=-1
        )
        
        # Hyperparameter tuning
        param_grid = {
            'n_estimators': [50, 100, 200],
            'max_depth': [10, 20, None],
            'min_samples_split': [2, 5, 10],
            'min_samples_leaf': [1, 2, 4]
        }
        
        grid_search = GridSearchCV(
            base_model, param_grid, cv=5, scoring='roc_auc', n_jobs=-1
        )
        
        grid_search.fit(X_train_scaled, y_train)
        
        # Get best model
        self.model = grid_search.best_estimator_
        
        # Evaluate model
        y_pred = self.model.predict(X_test_scaled)
        y_prob = self.model.predict_proba(X_test_scaled)[:, 1]
        
        # Calculate metrics
        accuracy = (y_pred == y_test).mean()
        auc = roc_auc_score(y_test, y_prob)
        
        logger.info(f"Model training completed")
        logger.info(f"Best parameters: {grid_search.best_params_}")
        logger.info(f"Test accuracy: {accuracy:.4f}")
        logger.info(f"Test AUC: {auc:.4f}")
        
        # Print detailed classification report
        logger.info("Classification Report:")
        logger.info(classification_report(y_test, y_pred))
        
        # Feature importance analysis
        feature_importance = self.model.feature_importances_
        top_features_idx = np.argsort(feature_importance)[-10:]  # Top 10 features
        
        logger.info("Top 10 most important features:")
        for idx in reversed(top_features_idx):
            feature_name = self.selected_features[idx] if self.selected_features else f"feature_{idx}"
            importance = feature_importance[idx]
            logger.info(f"  {feature_name}: {importance:.4f}")
    
    def save_model(self, output_dir: str) -> None:
        """
        Save the trained model and preprocessors.
        
        Args:
            output_dir: Directory to save model files
        """
        import os
        
        os.makedirs(output_dir, exist_ok=True)
        
        # Save model
        model_path = os.path.join(output_dir, 'apk_malware_rf.pkl')
        with open(model_path, 'wb') as f:
            pickle.dump(self.model, f)
        
        # Save scaler
        scaler_path = os.path.join(output_dir, 'apk_malware_rf_scaler.pkl')
        with open(scaler_path, 'wb') as f:
            pickle.dump(self.scaler, f)
        
        # Save feature selector
        selector_path = os.path.join(output_dir, 'apk_malware_rf_selector.pkl')
        with open(selector_path, 'wb') as f:
            pickle.dump(self.feature_selector, f)
        
        # Save feature names
        features_path = os.path.join(output_dir, 'apk_malware_rf_features.json')
        with open(features_path, 'w') as f:
            json.dump(self.selected_features, f)
        
        # Save label encoder if used
        if self.label_encoder:
            encoder_path = os.path.join(output_dir, 'apk_malware_rf_encoder.pkl')
            with open(encoder_path, 'wb') as f:
                pickle.dump(self.label_encoder, f)
        
        logger.info(f"Model saved to {output_dir}")
    
    def run_training_pipeline(self, data_path: str, output_dir: str, feature_count: int = 100) -> None:
        """
        Run the complete training pipeline.
        
        Args:
            data_path: Path to training data
            output_dir: Directory to save trained model
            feature_count: Number of features to select
        """
        logger.info("Starting APK malware detection training pipeline")
        
        try:
            # Load data
            df = self.load_data(data_path)
            
            # Prepare features
            X, y, feature_names = self.prepare_features(df)
            
            # Select features
            X_selected = self.select_features(X, y, feature_count)
            
            # Train model
            self.train_model(X_selected, y)
            
            # Save model
            self.save_model(output_dir)
            
            logger.info("Training pipeline completed successfully")
            
        except Exception as e:
            logger.error(f"Training pipeline failed: {e}")
            raise


def main():
    """Main function to run the training pipeline."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Train APK Malware Detection Model')
    parser.add_argument('--data', required=True, help='Path to training data file')
    parser.add_argument('--output', required=True, help='Output directory for model files')
    parser.add_argument('--features', type=int, default=100, help='Number of features to select')
    
    args = parser.parse_args()
    
    # Initialize trainer
    trainer = APKMalwareTrainer()
    
    # Run training pipeline
    trainer.run_training_pipeline(args.data, args.output, args.features)


if __name__ == "__main__":
    main()
